#+STARTUP: latexpreview
#+OPTIONS: tex:t

* Building a Modern Computer from First Principles

#+BEGIN_QUOTE
The cognitive ability to “divide and conquer” a complex system into manageable modules is empowered by yet another cognitive gift: our ability to discern between the abstraction and the implementation of each module. In computer science, we take these words concretely: abstraction describes what the module does, and implementation describes how it does it. With this distinction in mind, here is the most important rule in system engineering: when using a module as a building block—any module—you are to focus exclusively on the module’s abstraction, ignoring completely its implementation details.
#+END_QUOTE

** Hardware

*** Boolean Logic

#+BEGIN_QUOTE
The use of Boolean algebra for analyzing the abstract behavior of logic gates was articulated in 1937 by Claude Shannon, leading to what is sometimes described as the most important M.Sc. thesis in computer science. (p. 38)
#+END_QUOTE

| Operator | Math           | Formal       |
|----------+----------------+--------------|
| And      | $x \cdot y$    | $x \wedge y$ |
| Or       | $x + y$        | $x \vee y$   |
| Not      | $\overline{x}$ | $\neg x$     |

**** Not
If (in) out = 0, else out = 1

$f(x) = \neg x$

#+begin_src hdl :tangle projects/01/Not.hdl
CHIP Not {
    IN in;
    OUT out;

    PARTS:
    Nand(a=in, b=in, out=out);
}
#+end_src

**** And
if (a and b) out = 1, else out = 0

$f(x, y) = x \wedge y$

#+begin_src hdl :tangle projects/01/And.hdl
CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    Nand(a=a, b=b, out=neg);
    Not(in=neg, out=out);
}
#+end_src

**** Or
if (a or b) out = 1, else out = 0

$f(x, y) = x \vee y$

#+begin_src hdl :tangle projects/01/Or.hdl
CHIP Or {
    IN a, b;
    OUT out;

    PARTS:
    Not(in=a, out=na);
    Not(in=b, out=nb);
    Nand(a=na, b=nb, out=out);
}
#+end_src

**** Xor
if ((a and Not(b) or (Not(a) and b)) out = 1, else out = 0

$f(x, y) = (a \wedge \neg b) \vee (\neg a \wedge b)$

The naive implementation is straightforward:

#+begin_src hdl :tangle projects/01/BadXor.hdl
CHIP BadXor {
    IN a, b;
    OUT out;

    PARTS:
    Not(in=a, out=na);
    Not(in=b, out=nb);
    And(a=a, b=nb, out=fst);
    And(b=b, a=na, out=snd);
    Or(a=fst, b=snd, out=out);
}
#+end_src

Since we're using NAND as our basic building block here, AND/OR become expensive gates, costing 2 and 3 NAND, respectively. So this implementation uses 9 NAND. We can do better by applying De Morgan's Law, which defines the following tranformation rules:

$\neg (x \wedge y) \vdash (\neg x \vee \neg y)$

$\neg (x \vee y) \vdash (\neg x \wedge \neg y)$

So, our XOR function can be optimized to use only 5 NAND:

$f(x, y) = (a \wedge \neg b) \vee (\neg a \wedge b)$

$f(x, y) = \neg \neg ((a \wedge \neg b) \vee (\neg a \wedge b))$

$f(x, y) = \neg (\neg (a \wedge \neg b) \wedge \neg (\neg a \wedge b))$

That is: Nand(Nand(a, Not(b)), Nand(Not(a), b))

#+begin_src hdl :tangle projects/01/Xor.hdl
CHIP Xor {
    IN a, b;
    OUT out;

    PARTS:
    Not(in=a, out=na);
    Not(in=b, out=nb);
    Nand(a=a, b=nb, out=fst);
    Nand(b=b, a=na, out=snd);
    Nand(a=fst, b=snd, out=out);
}
#+end_src


**** Everything from NAND
Read appendix 1.
**** Table2Expr
Read appendix 1.
