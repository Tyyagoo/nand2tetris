#+STARTUP: latexpreview
#+OPTIONS: tex:t

* Building a Modern Computer from First Principles

#+BEGIN_QUOTE
The cognitive ability to “divide and conquer” a complex system into manageable modules is empowered by yet another cognitive gift: our ability to discern between the abstraction and the implementation of each module. In computer science, we take these words concretely: abstraction describes what the module does, and implementation describes how it does it. With this distinction in mind, here is the most important rule in system engineering: when using a module as a building block—any module—you are to focus exclusively on the module’s abstraction, ignoring completely its implementation details.
#+END_QUOTE

** Hardware

*** Boolean Logic

#+BEGIN_QUOTE
The use of Boolean algebra for analyzing the abstract behavior of logic gates was articulated in 1937 by Claude Shannon, leading to what is sometimes described as the most important M.Sc. thesis in computer science. (p. 38)
#+END_QUOTE

| Operator | Math           | Formal       |
|----------+----------------+--------------|
| And      | $x \cdot y$    | $x \wedge y$ |
| Or       | $x + y$        | $x \vee y$   |
| Not      | $\overline{x}$ | $\neg x$     |

**** Not
If (in) then out = 0, else out = 1

$f(x) = \neg x$

#+begin_src hdl :tangle projects/01/Not.hdl
CHIP Not {
    IN in;
    OUT out;

    PARTS:
    Nand(a=in, b=in, out=out);
}
#+end_src

**** And
if (a and b) then out = 1, else out = 0

$f(x, y) = x \wedge y$

#+begin_src hdl :tangle projects/01/And.hdl
CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    Nand(a=a, b=b, out=neg);
    Not(in=neg, out=out);
}
#+end_src

**** Or
if (a or b) then out = 1, else out = 0

$f(x, y) = x \vee y$

#+begin_src hdl :tangle projects/01/Or.hdl
CHIP Or {
    IN a, b;
    OUT out;

    PARTS:
    Not(in=a, out=na);
    Not(in=b, out=nb);
    Nand(a=na, b=nb, out=out);
}
#+end_src

**** Xor
if ((a and Not(b) or (Not(a) and b)) then out = 1, else out = 0

$f(x, y) = (a \wedge \neg b) \vee (\neg a \wedge b)$

The naive implementation is straightforward:

#+begin_src hdl :tangle projects/01/BadXor.hdl
CHIP BadXor {
    IN a, b;
    OUT out;

    PARTS:
    Not(in=a, out=na);
    Not(in=b, out=nb);
    And(a=a, b=nb, out=fst);
    And(b=b, a=na, out=snd);
    Or(a=fst, b=snd, out=out);
}
#+end_src

Since we're using NAND as our basic building block here, AND/OR become expensive gates, costing 2 and 3 NAND, respectively. So this implementation uses 9 NAND. We can do better by applying De Morgan's Law, which defines the following tranformation rules:

$\neg (x \wedge y) \vdash (\neg x \vee \neg y)$

$\neg (x \vee y) \vdash (\neg x \wedge \neg y)$

So, our XOR function can be optimized to use only 5 NAND:

$f(x, y) = (a \wedge \neg b) \vee (\neg a \wedge b)$

$f(x, y) = \neg \neg ((a \wedge \neg b) \vee (\neg a \wedge b))$

$f(x, y) = \neg (\neg (a \wedge \neg b) \wedge \neg (\neg a \wedge b))$

That is: Nand(Nand(a, Not(b)), Nand(Not(a), b))

#+begin_src hdl :tangle projects/01/Xor.hdl
CHIP Xor {
    IN a, b;
    OUT out;

    PARTS:
    Not(in=a, out=na);
    Not(in=b, out=nb);
    Nand(a=a, b=nb, out=fst);
    Nand(b=b, a=na, out=snd);
    Nand(a=fst, b=snd, out=out);
}
#+end_src

**** Mux
A multiplexer forwards a *given input* based on a selection criteria. N:1

if sel == 0 then out = a, else out = b

The logic is dead simple, short-circuit the unwanted value with SEL.

$f(x, y, s) = (x \wedge \neg s) \vee (y \wedge s)$

#+begin_src hdl :tangle projects/01/Mux.hdl
CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    Not(in=sel, out=nsel);
    Nand(a=a, b=nsel, out=x);
    Nand(a=b, b=sel, out=y);
    Nand(a=x, b=y, out=out);
}
#+end_src

**** Demux
A demultiplexer is the opposite. It forwards to a *given output* based on a selection criteria. 1:N

if sel == 0 then out = a, else out = b

$a(x, s) = x \wedge \neg s$

$b(x, s) = x \wedge s$

#+begin_src hdl :tangle projects/01/DMux.hdl
CHIP DMux {
    IN in, sel;
    OUT a, b;

    PARTS:
    Not(in=sel, out=nsel);
    And(a=in, b=sel, out=b);
    And(a=in, b=nsel, out=a);
}
#+end_src

**** Multi-bit Gates
#+begin_quote
The bits are indexed from right to left, the rightmost bit being the 0'th bit and the leftmost bit being the 15'th bit (in a 16-bit setting). (p. 49)
#+end_quote

#+begin_src hdl :tangle projects/01/Not16.hdl
CHIP Not16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Not(in=in[0], out=out[0]);
    Not(in=in[1], out=out[1]);
    Not(in=in[2], out=out[2]);
    Not(in=in[3], out=out[3]);
    Not(in=in[4], out=out[4]);
    Not(in=in[5], out=out[5]);
    Not(in=in[6], out=out[6]);
    Not(in=in[7], out=out[7]);
    Not(in=in[8], out=out[8]);
    Not(in=in[9], out=out[9]);
    Not(in=in[10], out=out[10]);
    Not(in=in[11], out=out[11]);
    Not(in=in[12], out=out[12]);
    Not(in=in[13], out=out[13]);
    Not(in=in[14], out=out[14]);
    Not(in=in[15], out=out[15]);
}
#+end_src

#+begin_src hdl :tangle projects/01/And16.hdl
CHIP And16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    And(a=a[0], b=b[0], out=out[0]);
    And(a=a[1], b=b[1], out=out[1]);
    And(a=a[2], b=b[2], out=out[2]);
    And(a=a[3], b=b[3], out=out[3]);
    And(a=a[4], b=b[4], out=out[4]);
    And(a=a[5], b=b[5], out=out[5]);
    And(a=a[6], b=b[6], out=out[6]);
    And(a=a[7], b=b[7], out=out[7]);
    And(a=a[8], b=b[8], out=out[8]);
    And(a=a[9], b=b[9], out=out[9]);
    And(a=a[10], b=b[10], out=out[10]);
    And(a=a[11], b=b[11], out=out[11]);
    And(a=a[12], b=b[12], out=out[12]);
    And(a=a[13], b=b[13], out=out[13]);
    And(a=a[14], b=b[14], out=out[14]);
    And(a=a[15], b=b[15], out=out[15]);
}
#+end_src

#+begin_src hdl :tangle projects/01/Or16.hdl
CHIP Or16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    Or(a=a[0], b=b[0], out=out[0]);
    Or(a=a[1], b=b[1], out=out[1]);
    Or(a=a[2], b=b[2], out=out[2]);
    Or(a=a[3], b=b[3], out=out[3]);
    Or(a=a[4], b=b[4], out=out[4]);
    Or(a=a[5], b=b[5], out=out[5]);
    Or(a=a[6], b=b[6], out=out[6]);
    Or(a=a[7], b=b[7], out=out[7]);
    Or(a=a[8], b=b[8], out=out[8]);
    Or(a=a[9], b=b[9], out=out[9]);
    Or(a=a[10], b=b[10], out=out[10]);
    Or(a=a[11], b=b[11], out=out[11]);
    Or(a=a[12], b=b[12], out=out[12]);
    Or(a=a[13], b=b[13], out=out[13]);
    Or(a=a[14], b=b[14], out=out[14]);
    Or(a=a[15], b=b[15], out=out[15]);
}
#+end_src

#+begin_src hdl :tangle projects/01/Mux16.hdl
CHIP Mux16 {
    IN a[16], b[16], sel;
    OUT out[16];

    PARTS:
    Mux(a=a[0], b=b[0], sel=sel, out=out[0]);
    Mux(a=a[1], b=b[1], sel=sel, out=out[1]);
    Mux(a=a[2], b=b[2], sel=sel, out=out[2]);
    Mux(a=a[3], b=b[3], sel=sel, out=out[3]);
    Mux(a=a[4], b=b[4], sel=sel, out=out[4]);
    Mux(a=a[5], b=b[5], sel=sel, out=out[5]);
    Mux(a=a[6], b=b[6], sel=sel, out=out[6]);
    Mux(a=a[7], b=b[7], sel=sel, out=out[7]);
    Mux(a=a[8], b=b[8], sel=sel, out=out[8]);
    Mux(a=a[9], b=b[9], sel=sel, out=out[9]);
    Mux(a=a[10], b=b[10], sel=sel, out=out[10]);
    Mux(a=a[11], b=b[11], sel=sel, out=out[11]);
    Mux(a=a[12], b=b[12], sel=sel, out=out[12]);
    Mux(a=a[13], b=b[13], sel=sel, out=out[13]);
    Mux(a=a[14], b=b[14], sel=sel, out=out[14]);
    Mux(a=a[15], b=b[15], sel=sel, out=out[15]);
}
#+end_src

**** Multi-way Gates
Basically a helper to apply a logic gate $n$ times.

#+begin_src hdl :tangle projects/01/Or8Way.hdl
CHIP Or8Way {
    IN in[8];
    OUT out;

    PARTS:
    Or(a=in[0], b=in[1], out=out1);
    Or(a=in[2], b=out1, out=out2);
    Or(a=in[3], b=out2, out=out3);
    Or(a=in[4], b=out3, out=out4);
    Or(a=in[5], b=out4, out=out5);
    Or(a=in[6], b=out5, out=out6);
    Or(a=in[7], b=out6, out=out);
}
#+end_src

#+begin_src hdl :tangle projects/01/Mux4Way16.hdl
CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    Mux16(a=a, b=b, sel=sel[0], out=x);
    Mux16(a=c, b=d, sel=sel[0], out=y);
    Mux16(a=x, b=y, sel=sel[1], out=out);
}
#+end_src

#+begin_src hdl :tangle projects/01/Mux8Way16.hdl
CHIP Mux8Way16 {
    IN a[16], b[16], c[16], d[16],
       e[16], f[16], g[16], h[16],
       sel[3];
    OUT out[16];

    PARTS:
    Mux4Way16(a=a, b=b, c=c, d=d, sel=sel[0..1], out=x);
    Mux4Way16(a=e, b=f, c=g, d=h, sel=sel[0..1], out=y);
    Mux16(a=x, b=y, sel=sel[2], out=out);
}
#+end_src

#+begin_src hdl :tangle projects/01/DMux4Way.hdl
CHIP DMux4Way {
    IN in, sel[2];
    OUT a, b, c, d;

    PARTS:
    DMux(in=in, sel=sel[1], a=ab, b=cd);
    DMux(in=ab, sel=sel[0], a=a, b=b);
    DMux(in=cd, sel=sel[0], a=c, b=d);
}
#+end_src

#+begin_src hdl :tangle projects/01/DMux8Way.hdl
CHIP DMux8Way {
    IN in, sel[3];
    OUT a, b, c, d, e, f, g, h;

    PARTS:
    DMux(in=in, sel=sel[2], a=abcd, b=efgh);
    DMux4Way(in=abcd, sel=sel[0..1], a=a, b=b, c=c, d=d);
    DMux4Way(in=efgh, sel=sel[0..1], a=e, b=f, c=g, d=h);
}
#+end_src

**** Everything from NAND
Read appendix 1.
**** Table2Expr
Read appendix 1.

*** Boolean Arithmetic

**** Half-adder

Since 1 + 1 = 0:

$s(x, y) = x \oplus y$

Only carries if both are 1:

$c(x, y) = x \wedge y$

#+begin_src hdl :tangle projects/02/HalfAdder.hdl
CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a, b=b, out=sum);
    And(a=a, b=b, out=carry);
}
#+end_src

**** Full-adder

Idk how to describe this with a equation, so fuck it.

#+begin_src hdl :tangle projects/02/FullAdder.hdl
CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    HalfAdder(a=a, b=b, carry=c1, sum=x);
    HalfAdder(a=x, b=c, carry=c2, sum=sum);
    Or(a=c1, b=c2, out=carry);
}
#+end_src

**** Adder

#+begin_src hdl :tangle projects/02/Add16.hdl
CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    HalfAdder(a=a[0], b=b[0], carry=c1, sum=out[0]);
    FullAdder(a=a[1], b=b[1], c=c1, carry=c2, sum=out[1]);
    FullAdder(a=a[2], b=b[2], c=c2, carry=c3, sum=out[2]);
    FullAdder(a=a[3], b=b[3], c=c3, carry=c4, sum=out[3]);
    FullAdder(a=a[4], b=b[4], c=c4, carry=c5, sum=out[4]);
    FullAdder(a=a[5], b=b[5], c=c5, carry=c6, sum=out[5]);
    FullAdder(a=a[6], b=b[6], c=c6, carry=c7, sum=out[6]);
    FullAdder(a=a[7], b=b[7], c=c7, carry=c8, sum=out[7]);
    FullAdder(a=a[8], b=b[8], c=c8, carry=c9, sum=out[8]);
    FullAdder(a=a[9], b=b[9], c=c9, carry=c10, sum=out[9]);
    FullAdder(a=a[10], b=b[10], c=c10, carry=c11, sum=out[10]);
    FullAdder(a=a[11], b=b[11], c=c11, carry=c12, sum=out[11]);
    FullAdder(a=a[12], b=b[12], c=c12, carry=c13, sum=out[12]);
    FullAdder(a=a[13], b=b[13], c=c13, carry=c14, sum=out[13]);
    FullAdder(a=a[14], b=b[14], c=c14, carry=c15, sum=out[14]);
    FullAdder(a=a[15], b=b[15], c=c15, carry=c16, sum=out[15]);
}
#+end_src

**** Incrementer

#+begin_src hdl :tangle projects/02/Inc16.hdl
CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    HalfAdder(a=in[0], b=true, carry=c1, sum=out[0]);
    HalfAdder(a=in[1], b=c1, carry=c2, sum=out[1]);
    HalfAdder(a=in[2], b=c2, carry=c3, sum=out[2]);
    HalfAdder(a=in[3], b=c3, carry=c4, sum=out[3]);
    HalfAdder(a=in[4], b=c4, carry=c5, sum=out[4]);
    HalfAdder(a=in[5], b=c5, carry=c6, sum=out[5]);
    HalfAdder(a=in[6], b=c6, carry=c7, sum=out[6]);
    HalfAdder(a=in[7], b=c7, carry=c8, sum=out[7]);
    HalfAdder(a=in[8], b=c8, carry=c9, sum=out[8]);
    HalfAdder(a=in[9], b=c9, carry=c10, sum=out[9]);
    HalfAdder(a=in[10], b=c10, carry=c11, sum=out[10]);
    HalfAdder(a=in[11], b=c11, carry=c12, sum=out[11]);
    HalfAdder(a=in[12], b=c12, carry=c13, sum=out[12]);
    HalfAdder(a=in[13], b=c13, carry=c14, sum=out[13]);
    HalfAdder(a=in[14], b=c14, carry=c15, sum=out[14]);
    HalfAdder(a=in[15], b=c15, carry=c16, sum=out[15]);
}
#+end_src

**** Arithmetic Logic Unit

wow.
